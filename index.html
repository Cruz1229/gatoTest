<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Gato en Realidad Aumentada</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            z-index: 999;
        }
        #turnoInfo {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            z-index: 999;
        }
        #resetButton {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 999;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ar.js/2.2.2/aframe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ar.js/2.2.2/aframe-ar.min.js"></script>
</head>
<body>
    <div id="info">Apunta la cámara hacia un marcador Hiro para comenzar a jugar</div>
    <div id="turnoInfo">Turno: Jugador X</div>
    <button id="resetButton">Reiniciar Juego</button>

    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;" renderer="antialias: true; alpha: true">
        <a-marker preset="hiro" id="hiromMarker">
            <!-- Aquí se creará el tablero de juego en Three.js -->
        </a-marker>
        <a-entity camera></a-entity>
    </a-scene>

    <script>
        // Variables globales
        let currentPlayer = 'X';
        let gameBoard = ['', '', '', '', '', '', '', '', ''];
        let gameActive = true;
        let scene, marker, raycaster, mouse;

        // Crear un objeto para almacenar referencias a las casillas 3D
        const cells3D = [];

        // Configuración inicial cuando la escena esté lista
        document.querySelector('a-scene').addEventListener('loaded', function () {
            // Obtener la escena Three.js de A-Frame
            scene = document.querySelector('a-scene').object3D;
            
            // Obtener el marcador
            marker = document.querySelector('a-marker').object3D;
            
            // Inicializar raycaster para detectar interacciones
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Crear el tablero de juego
            createGameBoard();
            
            // Agregar event listener para los clics
            document.addEventListener('click', onDocumentClick);
            
            // Botón de reinicio
            document.getElementById('resetButton').addEventListener('click', resetGame);
        });

        // Crear el tablero de juego
        function createGameBoard() {
            // Crear un grupo para contener el tablero
            const boardGroup = new THREE.Group();
            
            // Crear el fondo del tablero
            const boardGeometry = new THREE.BoxGeometry(3, 0.1, 3);
            const boardMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            boardGroup.add(board);
            
            // Crear las líneas del tablero
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            
            // Líneas horizontales
            const hLine1Geometry = new THREE.BoxGeometry(3, 0.1, 0.1);
            const hLine1 = new THREE.Mesh(hLine1Geometry, lineMaterial);
            hLine1.position.set(0, 0.1, -1);
            boardGroup.add(hLine1);
            
            const hLine2Geometry = new THREE.BoxGeometry(3, 0.1, 0.1);
            const hLine2 = new THREE.Mesh(hLine2Geometry, lineMaterial);
            hLine2.position.set(0, 0.1, 1);
            boardGroup.add(hLine2);
            
            // Líneas verticales
            const vLine1Geometry = new THREE.BoxGeometry(0.1, 0.1, 3);
            const vLine1 = new THREE.Mesh(vLine1Geometry, lineMaterial);
            vLine1.position.set(-1, 0.1, 0);
            boardGroup.add(vLine1);
            
            const vLine2Geometry = new THREE.BoxGeometry(0.1, 0.1, 3);
            const vLine2 = new THREE.Mesh(vLine2Geometry, lineMaterial);
            vLine2.position.set(1, 0.1, 0);
            boardGroup.add(vLine2);
            
            // Crear áreas clickeables para cada celda
            const positions = [
                [-2, 0, -2], [0, 0, -2], [2, 0, -2],
                [-2, 0, 0], [0, 0, 0], [2, 0, 0],
                [-2, 0, 2], [0, 0, 2], [2, 0, 2]
            ];
            
            for (let i = 0; i < 9; i++) {
                const cellGeometry = new THREE.BoxGeometry(0.9, 0.05, 0.9);
                const cellMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x666666, 
                    transparent: true, 
                    opacity: 0.0 
                });
                const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                
                // Calcular posición
                const row = Math.floor(i / 3);
                const col = i % 3;
                cell.position.set((col - 1) * 1, 0.15, (row - 1) * 1);
                
                // Almacenar el índice de la celda para identificación
                cell.userData.index = i;
                
                boardGroup.add(cell);
                cells3D.push(cell);
            }
            
            // Ajustar el tablero para que se vea bien en el marcador
            boardGroup.position.set(0, 0, 0);
            boardGroup.scale.set(0.5, 0.5, 0.5);
            
            // Agregar el tablero al marcador
            marker.add(boardGroup);
        }

        // Manejar los clics en el tablero
        function onDocumentClick(event) {
            if (!gameActive || !marker.visible) return;
            
            // Calcular las coordenadas del mouse normalizado
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Actualizar el raycaster
            raycaster.setFromCamera(mouse, document.querySelector('[camera]').object3D);
            
            // Verificar si el rayo intersecta con alguna celda
            const intersects = raycaster.intersectObjects(cells3D);
            
            if (intersects.length > 0) {
                const cellIndex = intersects[0].object.userData.index;
                
                // Verificar si la celda está vacía
                if (gameBoard[cellIndex] === '') {
                    // Marcar la celda
                    placeMarker(cellIndex);
                    
                    // Verificar si hay un ganador
                    if (checkWinner()) {
                        document.getElementById('turnoInfo').textContent = `¡Jugador ${currentPlayer} ha ganado!`;
                        gameActive = false;
                    } else if (gameBoard.every(cell => cell !== '')) {
                        // Empate
                        document.getElementById('turnoInfo').textContent = '¡Empate!';
                        gameActive = false;
                    } else {
                        // Cambiar de jugador
                        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                        document.getElementById('turnoInfo').textContent = `Turno: Jugador ${currentPlayer}`;
                    }
                }
            }
        }

        // Colocar una X o O en la celda
        function placeMarker(index) {
            // Actualizar el estado del tablero
            gameBoard[index] = currentPlayer;
            
            // Crear el marcador 3D (X u O)
            const markerGroup = new THREE.Group();
            
            if (currentPlayer === 'X') {
                // Crear una X
                const xMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                
                const line1Geometry = new THREE.BoxGeometry(0.6, 0.1, 0.1);
                const line1 = new THREE.Mesh(line1Geometry, xMaterial);
                line1.rotation.z = Math.PI / 4;
                markerGroup.add(line1);
                
                const line2Geometry = new THREE.BoxGeometry(0.6, 0.1, 0.1);
                const line2 = new THREE.Mesh(line2Geometry, xMaterial);
                line2.rotation.z = -Math.PI / 4;
                markerGroup.add(line2);
            } else {
                // Crear una O
                const oGeometry = new THREE.TorusGeometry(0.25, 0.08, 16, 32);
                const oMaterial = new THREE.MeshBasicMaterial({ color: 0x0000FF });
                const o = new THREE.Mesh(oGeometry, oMaterial);
                markerGroup.add(o);
            }
            
            // Calcular posición
            const row = Math.floor(index / 3);
            const col = index % 3;
            markerGroup.position.set((col - 1) * 1, 0.3, (row - 1) * 1);
            
            // Ajustar escala y posición
            markerGroup.scale.set(0.5, 0.5, 0.5);
            
            // Agregar el marcador al tablero
            cells3D[index].parent.add(markerGroup);
        }

        // Verificar si hay un ganador
        function checkWinner() {
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Filas
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columnas
                [0, 4, 8], [2, 4, 6]             // Diagonales
            ];
            
            return winPatterns.some(pattern => {
                return pattern.every(index => {
                    return gameBoard[index] === currentPlayer;
                });
            });
        }

        // Reiniciar el juego
        function resetGame() {
            // Limpiar el tablero
            gameBoard = ['', '', '', '', '', '', '', '', ''];
            gameActive = true;
            currentPlayer = 'X';
            
            // Actualizar el mensaje de turno
            document.getElementById('turnoInfo').textContent = 'Turno: Jugador X';
            
            // Eliminar los marcadores 3D
            cells3D.forEach(cell => {
                // Eliminar todos los hijos de la celda (las X y O)
                const parent = cell.parent;
                for (let i = parent.children.length - 1; i >= 0; i--) {
                    const child = parent.children[i];
                    if (child !== cell && child.type === 'Group') {
                        parent.remove(child);
                    }
                }
            });
        }
    </script>
</body>
</html>