<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Cuadrícula 3x3 en Realidad Aumentada</title>
    <!-- Cargar Three.js y AR.js desde CDNs confiables con versiones específicas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.3.3/three.js/build/ar.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <!-- Importante: Agregar atributo webgl para mejor soporte -->
    <div id="scene-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
    
    <script>
        // Variables globales
        let scene, camera, renderer;
        let arToolkitSource, arToolkitContext, markerRoot;

        // Inicializar
        function initialize() {
            // Crear escena, cámara y renderer
            scene = new THREE.Scene();
            camera = new THREE.Camera();
            scene.add(camera);
            
            // Configurar el renderizador
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                precision: 'highp' // Usar precisión alta para mejor calidad
            });
            renderer.setClearColor(new THREE.Color('lightgray'), 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0px';
            renderer.domElement.style.left = '0px';
            document.getElementById('scene-container').appendChild(renderer.domElement);
            
            // Configurar AR.js para la cámara
            arToolkitSource = new THREEx.ArToolkitSource({
                sourceType: 'webcam',
                sourceWidth: window.innerWidth > window.innerHeight ? 640 : 480,
                sourceHeight: window.innerWidth > window.innerHeight ? 480 : 640
            });
            
            arToolkitSource.init(function onReady() {
                // Redimensionar cuando esté listo
                setTimeout(function() {
                    onResize();
                }, 1000);
            });
            
            // Manejador de eventos para redimensionar
            window.addEventListener('resize', function() {
                onResize();
            });
            
            // Crear el contexto AR
            // Usar marcador 'hiro' - es el más estándar y estable
            arToolkitContext = new THREEx.ArToolkitContext({
                cameraParametersUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.3.3/data/data/camera_para.dat',
                detectionMode: 'mono',
                maxDetectionRate: 30,
                canvasWidth: 1000,
                canvasHeight: 1000
            });
            
            arToolkitContext.init(function onCompleted() {
                camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
            });
            
            // Crear marcador root
            markerRoot = new THREE.Group();
            scene.add(markerRoot);
            
            // Configurar el marcador - usar 'hiro' que es estable
            let markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
                type: 'pattern',
                patternUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.3.3/data/data/patt.hiro'
            });
            
            // Crear la cuadrícula 3x3
            crearCuadriculaTresXTres();
            
            // Iniciar animación
            animate();
        }
        
        function crearCuadriculaTresXTres() {
            // Grupo para contener todos los elementos
            const cuadricula = new THREE.Group();
            
            // Fondo blanco (plano) con un borde negro
            const backGeometry = new THREE.PlaneGeometry(1.5, 1.5);
            const backMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                side: THREE.DoubleSide 
            });
            const background = new THREE.Mesh(backGeometry, backMaterial);
            background.rotation.x = -Math.PI/2; // Horizontal
            cuadricula.add(background);
            
            // Agregar borde al cuadrado
            const borderGeometry = new THREE.EdgesGeometry(backGeometry);
            const borderMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            const border = new THREE.LineSegments(borderGeometry, borderMaterial);
            border.rotation.x = -Math.PI/2;
            cuadricula.add(border);
            
            // Tamaño de cada celda
            const cellSize = 0.5;
            
            // Crear líneas de la cuadrícula
            const linesMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
            
            // Líneas horizontales
            for (let i = 1; i <= 2; i++) {
                const y = -0.75 + i * cellSize;
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-0.75, 0, y),
                    new THREE.Vector3(0.75, 0, y)
                ]);
                const line = new THREE.Line(geometry, linesMaterial);
                cuadricula.add(line);
            }
            
            // Líneas verticales
            for (let i = 1; i <= 2; i++) {
                const x = -0.75 + i * cellSize;
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(x, 0, -0.75),
                    new THREE.Vector3(x, 0, 0.75)
                ]);
                const line = new THREE.Line(geometry, linesMaterial);
                cuadricula.add(line);
            }
            
            // Elevar ligeramente el grupo completo para evitar z-fighting
            cuadricula.position.y = 0.01;
            
            // Agregar el grupo al marcador
            markerRoot.add(cuadricula);
            
            // Agregar texto para saber si el marcador está siendo detectado
            const loader = new THREE.FontLoader();
            // Crear un texto provisional mientras se carga la fuente
            const geometryText = new THREE.TextGeometry("3x3", {
                size: 0.1,
                height: 0.02
            });
            const materialText = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const textMesh = new THREE.Mesh(geometryText, materialText);
            textMesh.position.set(0, 0.1, 0);
            textMesh.rotation.x = -Math.PI/2;
            cuadricula.add(textMesh);
        }
        
        function onResize() {
            arToolkitSource.onResizeElement();
            arToolkitSource.copyElementSizeTo(renderer.domElement);
            if (arToolkitContext.arController !== null) {
                arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (arToolkitSource.ready !== false) {
                arToolkitContext.update(arToolkitSource.domElement);
            }
            
            renderer.render(scene, camera);
        }
        
        // Iniciar la aplicación cuando se cargue la página
        window.onload = initialize;
    </script>
</body>
</html>